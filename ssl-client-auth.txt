Client cert signing
===================
Python-based local certificate authority (CA).

Based on the guide at https://jamielinux.com/docs/openssl-certificate-authority/

$ mkdir root-ca
$ cd root-ca
$ mkdir certs crl newcerts private
$ chmod 700 private
$ touch index.txt
$ echo 1000 > serial

Create a configuration specific to the root CA.
Copy https://jamielinux.com/docs/openssl-certificate-authority/_downloads/root-config.txt
to root-ca-openssl.conf amending the top level dir entry as appropriate.

$ openssl genrsa -aes256 -out private/ca.key.pem 4096
$ chmod 400 private/ca.key.pem

Enter the private key passphrase and answer the questions

$ openssl req -config root-ca-openssl.conf  \
      -key private/ca.key.pem \
      -new -x509 -days 7300 -sha256 -extensions v3_ca \
      -out certs/ca.cert.pem
Enter pass phrase for private/ca.key.pem:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [GB]:
State or Province Name [England]:England
Locality Name []:Hampshire
Organization Name [Alice Ltd]:Package Inventory Services
Organizational Unit Name []:Package Inventory Services Root CA
Common Name []:root-ca.localdomain
Email Address []:root-ca@localhost
$ chmod 444 certs/ca.cert.pem

Verify the certificate
$ openssl x509 -noout -text -in certs/ca.cert.pem

Create the intermediate pair, signed by the root, but used to sign the issued
certs on behalf of the root.

From https://jamielinux.com/docs/openssl-certificate-authority/create-the-intermediate-pair.html
$ mkdir intermediate-ca
$ cd intermediate-ca
$ mkdir certs crl csr newcerts private
$ chmod 700 private
$ touch index.txt
$ echo 1000 > serial
$ echo 1000 > crlnumber
$ echo "unique_subject = no" > index.txt.attr - see [15]
$ cp ../root-ca/root-ca-openssl.conf intermediate-openssl.conf

Make the following changes to the conf file:
[ CA_default ]
dir             = /root/ca/intermediate
private_key     = $dir/private/intermediate.key.pem
certificate     = $dir/certs/intermediate.cert.pem
crl             = $dir/crl/intermediate.crl.pem
policy          = policy_loose

Now generate the intermediate key
$ cd intermediate-ca
$ openssl genrsa -aes256 \
      -out private/intermediate.key.pem 4096
$ openssl req -config intermediate-openssl.conf -new -sha256 \
      -key private/intermediate.key.pem \
      -out csr/intermediate.csr.pem
      Enter pass phrase for private/intermediate.key.pem:
      You are about to be asked to enter information that will be incorporated
      into your certificate request.
      What you are about to enter is what is called a Distinguished Name or a DN.
      There are quite a few fields but you can leave some blank
      For some fields there will be a default value,
      If you enter '.', the field will be left blank.
      -----
      Country Name (2 letter code) [GB]:
      State or Province Name [England]:England
      Locality Name []:Hampshire
      Organization Name [Alice Ltd]:Package Inventory Services
      Organizational Unit Name []:Package Inventory Services Intermediate CA
      Common Name []:intermediate-ca@localdomain
      Email Address []:intermediate-ca@localhost

When creating the certificate, use the root ca openssl configuration
$ openssl ca -config ../root-ca/root-ca-openssl.conf -extensions v3_intermediate_ca \
      -days 3650 -notext -md sha256 \
      -in csr/intermediate.csr.pem \
      -out certs/intermediate.cert.pem
      Check that the request matches the signature
      Signature ok
      Certificate Details:
...
Certificate is to be certified until Nov 26 21:57:04 2026 GMT (3650 days)
Sign the certificate? [y/n]:y


1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base UpdatedCertificate is to be certified until Nov 26 21:57:04 2026 GMT (3650 days)
Sign the certificate? [y/n]:y


1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base Updated
$ chmod 444 certs/intermediate.cert.pem

Check that the root CA index.txt file contains an entry like,
$ more ../root-ca/index.txt
V	261126215704Z		1000	unknown	/C=GB/ST=Denial/O=Package Inventory Services/OU=Package Inventory Services Certificate Authority/CN=Package Inventory Services Intermediate CA

Verify the certificate and the chin of trust
$ openssl x509 -noout -text -in certs/intermediate.cert.pem
$ openssl verify -CAfile ../root-ca/certs/ca.cert.pem certs/intermediate.cert.pem
certs/intermediate.cert.pem: OK

Create a certificate chain so that clients can verify the intermediate against
the root certificate,
$ cat certs/intermediate.cert.pem ../root-ca/certs/ca.cert.pem > certs/ca-chain.cert.pem
$ chmod 444 certs/ca-chain.cert.pem


10 December 2016
----------------
To do the client cert authentication.

Install nginx as the reverse-proxy web server as described at [8]

Add an enty to /etc/hosts for the server component.

Prepare a certificate key pair for the server,

$ openssl genrsa -des3 -out inventory-master.key 1024
Generating RSA private key, 1024 bit long modulus
.............++++++
......++++++
e is 65537 (0x10001)
Enter pass phrase for inventory-master.key:
Verifying - Enter pass phrase for inventory-master.key:

Create a certificate signing request (CSR)
------------------------------------------
For the Python Requests library to work with the server certificate, we need to
make sure that the CSR includes SubjectAlternateNames. This needs an addition to
the intermediate-openssl.conf by adding  new section:

[ v3_req ]

# Extensions to add to a certificate request

basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alternate_names

And then including this in

[req]
...
req_extensions     = v3_req

$ openssl req -new -key inventory-master.key -out inventory-master.csr -config intermediate-openssl.conf

Or, to create the CSR and (passphraseless key) in one command,

$ openssl req -newkey rsa:1024 -keyout inventory-master.key -nodes -config intermediate-openssl.conf -out inventory-master.csr

Verify the inclusion of the SAN in the CSR,
openssl req -text -noout -in inventory-master.csr
...
            X509v3 Subject Alternative Name:
                DNS:inventory-master.localdomain, DNS:www.inventory-master.localdomain

Now, sign the CSR with the intermediate CA certificate,

$ openssl x509 -req -days 365 -in inventory-master.csr -CA certs/intermediate.cert.pem -CAkey private/intermediate.key.pem -set_serial 01 -out inventory-master.crt -extensions v3_req -extfile intermediate-openssl.conf
Signature ok
subject=/C=GB/ST=Denial/L=Yateley/O=Package Inventory Services/OU=Infrastructure/CN=inventory-master.localdomain
Getting CA Private Key
Enter pass phrase for intermediate.key.pem:

Verify the certificate contains the SANs

$ openssl x509 -noout -text -in inventory-master.crt
...
            X509v3 Subject Alternative Name:
                DNS:inventory-master.localdomain, DNS:www.inventory-master.localdomain

Now, most sources point to best practice is to use passphrases to encrypt the
private key, but it does make them much harder to use and stuff has a habit of
not working. And when it doesn't work it is a nightmare to troubleshoot with
just a '400 - Bad request' at the reverse proxy and no other indications.

Verify that the key matches the certificate,
$ openssl x509 -noout -modulus -in ssl/fnunbob.localdomain.cert.pem | openssl md5
(stdin)= 79a6abe2e4e69ace8305ce562dfa9ec2
$ openssl rsa -noout -modulus -in ssl/fnunbob.localdomain.key.pem |openssl md5
(stdin)= 79a6abe2e4e69ace8305ce562dfa9ec2

To convert the certificate and key to pkcs12 format (for importing into a web
browser for testing purposes):

$ openssl pkcs12 -export -out ssl/fnunbob.localdomain.pfx -inkey ssl/fnunbob.localdomain.key.pem -in ssl/fnunbob.localdomain.cert.pem -certfile ~/Projects/python/client-cert-auth/intermediate-ca/certs/ca-chain.cert.pem
Enter Export Password:
Verifying - Enter Export Password:

(The passphrase will be empty)

Create a directory, /etc/nginx/ssl, and install a copy of the cert and key,
adding the intermediate certificate chain to the end of the server cert.

Create a file in the /etc/nginx/ssl directory containing the passphrase for the
private key if used.

http://stackoverflow.com/questions/30405867/how-to-get-python-requests-to-trust-a-self-signed-ssl-certificate
describes what needs to be added to a Python Requests call to trust a
self-signed root CA.

Setting up Nginx and uwsgi for secure serving of Flask application described at
https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-14-04

$ sudo -s
# cd /var/www/
# virtualenv PackageInventoryServer
Using base prefix '/usr'
New python executable in /var/www/PackageInventoryServer/bin/python
Installing setuptools, pip, wheel...done.
#

Start the virtual mchine and install the required pips in the virtualenv

# source PackageInventoryServer/bin/activate
# pip install uwsgi flask json OpenSSL
Collecting uwsgi
  Using cached uwsgi-2.0.14.tar.gz
Collecting flask
  Using cached Flask-0.11.1-py2.py3-none-any.whl
Collecting pyOpenSSL
  Using cached pyOpenSSL-16.2.0-py2.py3-none-any.whl
Collecting click>=2.0 (from flask)
  Downloading click-6.6-py2.py3-none-any.whl (71kB)
    100% |████████████████████████████████| 71kB 1.0MB/s
Collecting Jinja2>=2.4 (from flask)
  Using cached Jinja2-2.8-py2.py3-none-any.whl
Collecting Werkzeug>=0.7 (from flask)
  Using cached Werkzeug-0.11.11-py2.py3-none-any.whl
Collecting itsdangerous>=0.21 (from flask)
  Using cached itsdangerous-0.24.tar.gz
Collecting six>=1.5.2 (from pyOpenSSL)
  Downloading six-1.10.0-py2.py3-none-any.whl
Collecting cryptography>=1.3.4 (from pyOpenSSL)
  Using cached cryptography-1.6.tar.gz
Collecting MarkupSafe (from Jinja2>=2.4->flask)
  Downloading MarkupSafe-0.23.tar.gz
Collecting idna>=2.0 (from cryptography>=1.3.4->pyOpenSSL)
  Using cached idna-2.1-py2.py3-none-any.whl
Collecting pyasn1>=0.1.8 (from cryptography>=1.3.4->pyOpenSSL)
  Using cached pyasn1-0.1.9-py2.py3-none-any.whl
Requirement already satisfied: setuptools>=11.3 in ./PackageInventoryServer/lib/python3.5/site-packages (from cryptography>=1.3.4->pyOpenSSL)
Collecting cffi>=1.4.1 (from cryptography>=1.3.4->pyOpenSSL)
  Using cached cffi-1.9.1-cp35-cp35m-manylinux1_x86_64.whl
Collecting pycparser (from cffi>=1.4.1->cryptography>=1.3.4->pyOpenSSL)
  Using cached pycparser-2.17.tar.gz
Building wheels for collected packages: uwsgi, itsdangerous, cryptography, MarkupSafe, pycparser
  Running setup.py bdist_wheel for uwsgi ... done
  Stored in directory: /root/.cache/pip/wheels/c4/ad/56/f70a70b63fa4b0f2c0518db6f41381c9d33cd5cc5ac9a9494b
  Running setup.py bdist_wheel for itsdangerous ... done
  Stored in directory: /root/.cache/pip/wheels/fc/a8/66/24d655233c757e178d45dea2de22a04c6d92766abfb741129a
  Running setup.py bdist_wheel for cryptography ... done
  Stored in directory: /root/.cache/pip/wheels/c1/b0/c1/00756c24fd3ad4bba815bacbbbaa819718ecb63039e379ea6b
  Running setup.py bdist_wheel for MarkupSafe ... done
  Stored in directory: /root/.cache/pip/wheels/a3/fa/dc/0198eed9ad95489b8a4f45d14dd5d2aee3f8984e46862c5748
  Running setup.py bdist_wheel for pycparser ... done
  Stored in directory: /root/.cache/pip/wheels/a8/0b/41/dc95621f9d3a0da7bc191b8a71f0e8182ffd3cc5f33ac55005
Successfully built uwsgi itsdangerous cryptography MarkupSafe pycparser
Installing collected packages: uwsgi, click, MarkupSafe, Jinja2, Werkzeug, itsdangerous, flask, six, idna, pyasn1, pycparser, cffi, cryptography, pyOpenSSL
Successfully installed Jinja2-2.8 MarkupSafe-0.23 Werkzeug-0.11.11 cffi-1.9.1 click-6.6 cryptography-1.6 flask-0.11.1 idna-2.1 itsdangerous-0.24 pyOpenSSL-16.2.0 pyasn1-0.1.9 pycparser-2.17 six-1.10.0 uwsgi-2.0.14

Create a wsgi wrapper to run the application, say, wsgi.py, bearing in mind that
uwsgi expects the imported application to be called application,

wsgi.py should contain

from PackageInventoryServer import app as application

if __name__ == "__main__":
    application.run()

It can be launched using,

$ uwsgi --socket 0.0.0.0:5000 --protocol=http -w wsgi

Provide a wrapper for uwsgi to launch the Flask application, create a file
describing how to run the application, called, say, application.ini, with

[uwsgi]
module = wsgi

master = true
processes = 5

socket = application.sock
chmod-socket = 666
vacuum = true

die-on-term = true


The chmod-socket setting needs to be sufficient for the user running the
virtualenv; nginx runs as http on Arch Linux.

The wsgi application can be started in the virtual environment using,

# uwsgi --ini application.ini

Use the following Nginx configuration,
server {
    listen        443;
    ssl on;
    server_name inventory-master.localdomain;

    ssl_certificate      /etc/nginx/ssl/inventory-master.crt;
    ssl_certificate_key  /etc/nginx/ssl/inventory-master.key;
    ssl_trusted_certificate /etc/nginx/ssl/ca-chain.crt;
    ssl_client_certificate /etc/nginx/ssl/ca-chain.crt;
    ssl_verify_client optional;
    ssl_verify_depth 3;

    location / {
        root           /var/www/example.com/html;
        root   html;
        index  index.html index.htm;
        include uwsgi_params;
        uwsgi_pass unix:/var/www/application/application.sock;
    }
}

Keep ssl_verify_client as optional while developing the solution.

The nginx environment can be tested with 'nginx -t' and started normally with

# systemctl start nginx

Although a browser won't be the interface that the application is using, we can
still view the site by pointing https://inventory-master.localdomin/
The ssl_verify_client option set to 'on' should mean that a plain request for a
resource is returnned with a '400' bad request: No required SSL certificate was sent.


Testing with cURL:
Create a key and CSR,
openssl req -newkey rsa:1024 -keyout fnunbob.key -nodes -config intermediate-openssl.conf -out fnunbob.csr
enerating a 1024 bit RSA private key
...........++++++
............................................................................++++++
writing new private key to 'fnunbob.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [GB]:
State or Province Name [England]:
Locality Name []:Hampshire
Organization Name [Alice Ltd]:Package Inventory Services
Organizational Unit Name []:Inventory Team
Common Name []:fnunbob.localdomain
Email Address []:.

curl -v https://inventory-master.localdomain/package-inventory/client-cert/new --cacert /home/julian/Projects/client-cert-auth/intermediate-ca/certs/ca-chain.cert.pem -H 'Content-Type: application/pkcs10' -k -d '
-----BEGIN CERTIFICATE REQUEST-----
MIICQjCCAasCAQAwgY8xCzAJBgNVBAYTAkdCMRAwDgYDVQQIDAdFbmdsYW5kMRIw
...
fp1O0gQA20BaZAPN6FfpUITCdgxRh/usprzpDbi/Lz/A3hslFBmXwiC4S8QRTRbp
5a8NOAC8
-----END CERTIFICATE REQUEST-----'

# Test a post without a client cert
curl -k -v https://inventory-master.localdomain/package-inventory/packages/new -H 'Content-Type: application/json' \
-d '{"hostname": "fnunbob.localdomain", "Packages": [{"Version": "1:1.2.8-7", "Architecture": "x86_64", "Name": "zlib", "Description": "Compression library implementing the deflate compression method found in gzip and PKZIP", "URL": "http://www.zlib.net/"}]}'

# Testing with a client cert
curl -v https://inventory-master.localdomain/package-inventory/packages/new \
--cacert /home/julian/Projects/client-cert-auth/intermediate-ca/certs/ca-chain.cert.pem \
--cert /home/julian/Projects/ruby/package-inventory-server/python/ssl/fnunbob.localdomain.cert.pem \
--key /home/julian/Projects/ruby/package-inventory-server/python/ssl/fnunbob.localdomain.key.pem \
-H 'Content-Type: application/json' -k \
-d '{"hostname": "fnunbob.localdomain", "Packages": [{"Version": "1:1.2.8-7", "Architecture": "x86_64", "Name": "zlib", "Description": "Compression library implementing the deflate compression method found in gzip and PKZIP", "URL": "http://www.zlib.net/"}]}' -d '{"hostname": "fnunbob.localdomain", "Packages": [{"Version": "1:1.2.8-7", "Architecture": "x86_64", "Name": "zlib", "Description": "Compression library implementing the deflate compression method found in gzip and PKZIP", "URL": "http://www.zlib.net/"}]}'


When testing in Python using Requests, we will need to trust the self-signed
cert as described at http://stackoverflow.com/questions/30405867/how-to-get-python-requests-to-trust-a-self-signed-ssl-certificate
using 'verify=False' or by specifying the path to the CA chain.

It might be possible to start flask with SSL options as described at
http://kracekumar.com/post/54437887454/ssl-for-flask-local-development


Troubleshooting
===============

If the following error is received:

/usr/lib/python3.5/site-packages/urllib3/connection.py:337: SubjectAltNameWarning: Certificate for inventory-master.localdomain has no `subjectAltName`, falling back to check for a `commonName` for now. This feature is being removed by major browsers and deprecated by RFC 2818. (See https://github.com/shazow/urllib3/issues/497 for details.)
  SubjectAltNameWarning
send_package_list: <html>
<head><title>400 The SSL certificate error</title></head>

See [7]

Edit the config being used to sign the CSRs and add a new section,

[ alternate_names ]
DNS.1 = inventory-master.localdomain
DNS.2 = www.inventory-master.localdomain

And then add,

subjectAltName      = @alternate_names

to the section pointed to by x509_extensions (usually [v3_ca] although perhaps
[v3_intermediate_ca] would be more accurate in this case).

Make sure that the certificate request is created using an SSL config that
includes the SAN (SubjectAltName) configuration and that an openssl configuration
that contains req extensions that feature SubjectAlternateNames is used:

openssl x509 ... -extensions v3_req -extfile intermediate-openssl.conf

The openssl conf in this example would include:

[ v3_req ]

# Extensions to add to a certificate request

basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alternate_names

And then including this in

[req]
...
req_extensions     = v3_req

See [5] and [6]

---------------
Testing the basic response from the server with a client cert and key
$ python
>>> import requests
>>> requests.get('https://inventory-master.localdomain/', cert=('/path/server.crt', '/path/key'))
raceback (most recent call last):
  File "/usr/lib/python3.5/site-packages/urllib3/connectionpool.py", line 594, in urlopen
    chunked=chunked)
  File "/usr/lib/python3.5/site-packages/urllib3/connectionpool.py", line 350, in _make_request
    self._validate_conn(conn)
  File "/usr/lib/python3.5/site-packages/urllib3/connectionpool.py", line 835, in _validate_conn
    conn.connect()
  File "/usr/lib/python3.5/site-packages/urllib3/connection.py", line 323, in connect
    ssl_context=context)
  File "/usr/lib/python3.5/site-packages/urllib3/util/ssl_.py", line 324, in ssl_wrap_socket
    return context.wrap_socket(sock, server_hostname=server_hostname)
  File "/usr/lib/python3.5/ssl.py", line 377, in wrap_socket
    _context=self)
  File "/usr/lib/python3.5/ssl.py", line 752, in __init__
    self.do_handshake()
  File "/usr/lib/python3.5/ssl.py", line 988, in do_handshake
    self._sslobj.do_handshake()
  File "/usr/lib/python3.5/ssl.py", line 633, in do_handshake
    self._sslobj.do_handshake()
ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/lib/python3.5/site-packages/requests/adapters.py", line 423, in send
    timeout=timeout
  File "/usr/lib/python3.5/site-packages/urllib3/connectionpool.py", line 624, in urlopen
    raise SSLError(e)
requests.packages.urllib3.exceptions.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python3.5/site-packages/requests/api.py", line 70, in get
    return request('get', url, params=params, **kwargs)
  File "/usr/lib/python3.5/site-packages/requests/api.py", line 56, in request
    return session.request(method=method, url=url, **kwargs)
  File "/usr/lib/python3.5/site-packages/requests/sessions.py", line 488, in request
    resp = self.send(prep, **send_kwargs)
  File "/usr/lib/python3.5/site-packages/requests/sessions.py", line 609, in send
    r = adapter.send(request, **kwargs)
  File "/usr/lib/python3.5/site-packages/requests/adapters.py", line 497, in send
    raise SSLError(e, request=request)
requests.exceptions.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)

We can also use the verify option to pass in the CA certificate chain used to
sign the certificate request.

>>> requests.get('https://inventory-master.localdomain/', cert=('ssl/fnunbob.localdomain.cert.pem', 'ssl/fnunbob.localdomain.key.pem'), verify='/home/julian/Projects/python/client-cert-auth/intermediate-ca/certs/ca-chain.cert.pem')
<Response [400]>

This response is from the web server rather than the Flask/uwsgi application.

$ openssl s_client -showcerts -connect inventory-master.localdomain:443 > /tmp/cacert.pem
depth=2 C = GB, ST = England, L = Hampshire, O = Package Inventory Services, OU = Package Inventory Services Root CA, CN = root-ca.localdomain, emailAddress = root-ca@localhost
verify error:num=19:self signed certificate in certificate chain
140704756164248:error:14094410:SSL routines:ssl3_read_bytes:sslv3 alert handshake failure:s3_pkt.c:1487:SSL alert number 40
140704756164248:error:140790E5:SSL routines:ssl23_write:ssl handshake failure:s23_lib.c:177:
So why do reports (e.g. [16]) say that this command works first time for a
self-signed certificate?

$ openssl s_client -connect inventory-master.localdomain:443 -key inventory-master.key -showcerts \
                 -cert inventory-master.crt
Show the full certificate path being used by the server

$ openssl s_client -connect inventory-master.localdomain:443/package-inventory/heartbeat \
-status -cert fnunbob-localdomain.crt -key fnunbob.key -verify 1 -showcerts \
-CAfile certs/ca-chain.cert.pem

This can help identify any stray certificates that don't belong in the CA chain.

References
==========
There is a lot of material on this difficult subject; you mileage will vary, but
below is a selection of articles that were useful preparing this document. Note
how many are related to the Python side of things.

[1] https://pypi.python.org/pypi/blitz-ca/0.1.1 - Python local CA; not used here
[2] http://stackoverflow.com/questions/33504746/doing-ssl-client-authentication-is-python
[3] http://stackoverflow.com/questions/9093289/how-to-create-a-dual-authentication-https-client-in-python-without-lgpl-libs
[4] http://twistedmatrix.com/documents/current/core/howto/ssl.html#client-authentication
[5] http://wiki.cacert.org/FAQ/subjectAltName - Adding SubjectAltName to a cert
Might be possible to use https://github.com/httplib2/httplib2 but it doesn't
look like it supports SSL client auth.
[6] http://apetec.com/support/generatesan-csr.htm - for creating SAN server
certificates (even though the cert creation command is missing a space in the
argument list).
[7] http://stackoverflow.com/questions/21488845/how-can-i-generate-a-self-signed-certificate-with-subjectaltname-using-openssl
gives a good description; ignore the off-topic moan; it is directly related
to programming as I can testify in this example.
[8] http://blog.nategood.com/client-side-certificate-authentication-in-ngi
[9] https://jamielinux.com/docs/openssl-certificate-authority/ - an excellent
guide except that it is missing the need to use SubjectAlternateNames.
[10] https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-14-04
A good guide to fronting Flask applications with uwsgi and Nginx.
[11] http://stackoverflow.com/questions/30405867/how-to-get-python-requests-to-trust-a-self-signed-ssl-certificate
How to get Python Requests calls to trust self-signed certificates.
[12] http://serverfault.com/questions/721572/nginx-verifying-client-certs-only-on-a-particular-location
Location-based authorisation so that CSRs and heartbeats can be processed
without requiring a cert; everything else does; we're not bothered if it
doesn't work for one browser or another.
[13] https://support.globalsign.com/customer/portal/articles/1353601-converting-certificates---openssl
Converting certs and keys from one format to another. Lots of sites will do this
[14] https://kb.wisc.edu/middleware/page.php?id=4064https://kb.wisc.edu/middleware/page.php?id=4064
Verifying that a certificate and key match.
[15] http://stackoverflow.com/questions/9496698/how-to-revoke-an-openssl-certificate-when-you-dont-have-the-certificate
How to get past certificate database errors when re-requesting a replacement
[16] http://stackoverflow.com/questions/7885785/using-openssl-to-get-the-certificate-from-a-server
Getting openssl to report the certificates in use on a server.
[17] http://stackoverflow.com/questions/10175812/how-to-create-a-self-signed-certificate-with-opensslhttp://stackoverflow.com/questions/10175812/how-to-create-a-self-signed-certificate-with-openssl
Perhaps a better guide to correctly setting up root CA to self-sign trusted certs
[18] http://serverfault.com/questions/453300/openssl-client-authentication-error-tlsv1-alert-unknown-ca-ssl-alert-numbe
Another problem that can occur when using openssl to diagnose http 400 errors
