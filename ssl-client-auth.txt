Client cert signing
===================
Python-based local certificate authority (CA).

Based on the guide at https://jamielinux.com/docs/openssl-certificate-authority/

$ mkdir root-ca
$ cd root-ca
$ mkdir certs crl newcerts private
$ chmod 700 private
$ touch index.txt
$ echo 1000 > serial

Create a configuration specific to the root CA.
Copy https://jamielinux.com/docs/openssl-certificate-authority/_downloads/root-config.txt
to root-ca-openssl.conf amending the top level dir entry as appropriate.

$ openssl genrsa -aes256 -out private/ca.key.pem 4096
$ chmod 400 private/ca.key.pem

Enter the priavte key passphrase and answer the questions

$ openssl req -config root-ca-openssl.conf  \
      -key private/ca.key.pem \
      -new -x509 -days 7300 -sha256 -extensions v3_ca \
      -out certs/ca.cert.pem
Enter pass phrase for private/ca.key.pem:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [GB]:
State or Province Name [England]:Denial
Locality Name []:.
Organization Name [Alice Ltd]:Package Inventory Services
Organizational Unit Name []:.
Common Name []:fnunbob.localdomain
Email Address []:julian@localhost
$ chmod 444 certs/ca.cert.pem

Verify the certificate
$ openssl x509 -noout -text -in certs/ca.cert.pem

Create the intermediate pair, signed by the root, but used to sign the issued
certs on behalf of the root.

From https://jamielinux.com/docs/openssl-certificate-authority/create-the-intermediate-pair.html
$ mkdir intermediate-ca
$ cd intermediate-ca
$ mkdir certs crl csr newcerts private
$ chmod 700 private
$ touch index.txt
$ echo 1000 > serial
$ echo 1000 > crlnumber
$ cp ../root-ca/root-ca-openssl.conf intermediate-openssl.conf
Make the following changes to the conf file:
[ CA_default ]
dir             = /root/ca/intermediate
private_key     = $dir/private/intermediate.key.pem
certificate     = $dir/certs/intermediate.cert.pem
crl             = $dir/crl/intermediate.crl.pem
policy          = policy_loose

Now generate the intermediate key
$ cd intermediate-ca
$ openssl genrsa -aes256 \
      -out private/intermediate.key.pem 4096
$ openssl req -config intermediate-openssl.conf -new -sha256 \
      -key private/intermediate.key.pem \
      -out csr/intermediate.csr.pem
      Enter pass phrase for private/intermediate.key.pem:
      You are about to be asked to enter information that will be incorporated
      into your certificate request.
      What you are about to enter is what is called a Distinguished Name or a DN.
      There are quite a few fields but you can leave some blank
      For some fields there will be a default value,
      If you enter '.', the field will be left blank.
      -----
      Country Name (2 letter code) [GB]:
      State or Province Name [England]:Denial
      Locality Name []:
      Organization Name [Alice Ltd]:Package Inventory Services
      Organizational Unit Name []:Package Inventory Services Certificate Authority
      Common Name []:Package Inventory Services Intermediate CA
      Email Address []:.

When creating the certificate, use the root ca openssl configuration
$ openssl ca -config ../root-ca/root-ca-openssl.conf -extensions v3_intermediate_ca \
      -days 3650 -notext -md sha256 \
      -in csr/intermediate.csr.pem \
      -out certs/intermediate.cert.pem
      Check that the request matches the signature
      Signature ok
      Certificate Details:
...
Certificate is to be certified until Nov 26 21:57:04 2026 GMT (3650 days)
Sign the certificate? [y/n]:y


1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base UpdatedCertificate is to be certified until Nov 26 21:57:04 2026 GMT (3650 days)
Sign the certificate? [y/n]:y


1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base Updated
$ chmod 444 certs/intermediate.cert.pem

Check that the root CA index.txt file contains an entry like,
$ more ../root-ca/index.txt
V	261126215704Z		1000	unknown	/C=GB/ST=Denial/O=Package Inventory Services/OU=Package Inventory Services Certificate Authority/CN=Package Inventory Services Intermediate CA

Verify the certificate and the chin of trust
$ openssl x509 -noout -text -in certs/intermediate.cert.pem
$ openssl verify -CAfile ../root-ca/certs/ca.cert.pem certs/intermediate.cert.pem
certs/intermediate.cert.pem: OK

Create a certificate chain so that clients can verify the intermediate against
the root certificate,
$ cat certs/intermediate.cert.pem ../root-ca/certs/ca.cert.pem > certs/ca-chain.cert.pem
$ chmod 444 certs/ca-chain.cert.pem


10 December 2016
----------------
To do the client cert authentication.

Install nginx as the reverse-proxy web server as described at [8]

Add an enty to /etc/hosts for the server component.

Prepare a certificate key pair for the server,

$ openssl genrsa -des3 -out inventory-master.key 1024
Generating RSA private key, 1024 bit long modulus
.............++++++
......++++++
e is 65537 (0x10001)
Enter pass phrase for inventory-master.key:
Verifying - Enter pass phrase for inventory-master.key:

Create a certificate signing request (CSR)
------------------------------------------
For the Python Requests library to work with the server certificate, we need to
make sure that the CSR includes SubjectAlternateNames. This needs an addition to
the intermediate-openssl.conf by adding  new section:

[ v3_req ]

# Extensions to add to a certificate request

basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alternate_names

And then including this in

[req]
...
req_extensions     = v3_req

$ openssl req -new -key inventory-master.key -out inventory-master.csr -config intermediate-openssl.conf

Verify the inclusion of the SAN in the CSR,
openssl req -text -noout -in inventory-master.csr
...
            X509v3 Subject Alternative Name:
                DNS:inventory-master.localdomain, DNS:www.inventory-master.localdomain

Now, sign the CSR with the intermediate CA certificate,

$ openssl x509 -req -days 365 -in inventory-master.csr -CA certs/intermediate.cert.pem -CAkey private/intermediate.key.pem -set_serial 01 -out inventory-master.crt -extensions v3_req -extfile intermediate-openssl.conf
Signature ok
subject=/C=GB/ST=Denial/L=Yateley/O=Package Inventory Services/OU=Infrastructure/CN=inventory-master.localdomain
Getting CA Private Key
Enter pass phrase for intermediate.key.pem:

Verify the certificate contains the SANs

$ openssl x509 -noout -text -in inventory-master.crt
...
            X509v3 Subject Alternative Name:
                DNS:inventory-master.localdomain, DNS:www.inventory-master.localdomain

Create a directory, /etc/nginx/ssl, and install a copy of the cert and key,
adding the intermediate certificate chain to the end of the server cert.

Create a file in the /etc/nginx/ssl directory containing the passphrase for the
private key.

http://stackoverflow.com/questions/30405867/how-to-get-python-requests-to-trust-a-self-signed-ssl-certificatehttp://stackoverflow.com/questions/30405867/how-to-get-python-requests-to-trust-a-self-signed-ssl-certificate
describes what needs to be added to a Python Requests call to trust a self-signed root CA.

Setting up Nginx and uwsgi for secure serving of Flask application described at
https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-14-04

$ sudo -s
# cd /var/www/
# virtualenv PackageInventoryServer
Using base prefix '/usr'
New python executable in /var/www/PackageInventoryServer/bin/python
Installing setuptools, pip, wheel...done.
#

Start the virtual mchine and install the required pips in the virtualenv

# source PackageInventoryServer/bin/activate
# pip install uwsgi flask json OpenSSL
Collecting uwsgi
  Using cached uwsgi-2.0.14.tar.gz
Collecting flask
  Using cached Flask-0.11.1-py2.py3-none-any.whl
Collecting pyOpenSSL
  Using cached pyOpenSSL-16.2.0-py2.py3-none-any.whl
Collecting click>=2.0 (from flask)
  Downloading click-6.6-py2.py3-none-any.whl (71kB)
    100% |████████████████████████████████| 71kB 1.0MB/s
Collecting Jinja2>=2.4 (from flask)
  Using cached Jinja2-2.8-py2.py3-none-any.whl
Collecting Werkzeug>=0.7 (from flask)
  Using cached Werkzeug-0.11.11-py2.py3-none-any.whl
Collecting itsdangerous>=0.21 (from flask)
  Using cached itsdangerous-0.24.tar.gz
Collecting six>=1.5.2 (from pyOpenSSL)
  Downloading six-1.10.0-py2.py3-none-any.whl
Collecting cryptography>=1.3.4 (from pyOpenSSL)
  Using cached cryptography-1.6.tar.gz
Collecting MarkupSafe (from Jinja2>=2.4->flask)
  Downloading MarkupSafe-0.23.tar.gz
Collecting idna>=2.0 (from cryptography>=1.3.4->pyOpenSSL)
  Using cached idna-2.1-py2.py3-none-any.whl
Collecting pyasn1>=0.1.8 (from cryptography>=1.3.4->pyOpenSSL)
  Using cached pyasn1-0.1.9-py2.py3-none-any.whl
Requirement already satisfied: setuptools>=11.3 in ./PackageInventoryServer/lib/python3.5/site-packages (from cryptography>=1.3.4->pyOpenSSL)
Collecting cffi>=1.4.1 (from cryptography>=1.3.4->pyOpenSSL)
  Using cached cffi-1.9.1-cp35-cp35m-manylinux1_x86_64.whl
Collecting pycparser (from cffi>=1.4.1->cryptography>=1.3.4->pyOpenSSL)
  Using cached pycparser-2.17.tar.gz
Building wheels for collected packages: uwsgi, itsdangerous, cryptography, MarkupSafe, pycparser
  Running setup.py bdist_wheel for uwsgi ... done
  Stored in directory: /root/.cache/pip/wheels/c4/ad/56/f70a70b63fa4b0f2c0518db6f41381c9d33cd5cc5ac9a9494b
  Running setup.py bdist_wheel for itsdangerous ... done
  Stored in directory: /root/.cache/pip/wheels/fc/a8/66/24d655233c757e178d45dea2de22a04c6d92766abfb741129a
  Running setup.py bdist_wheel for cryptography ... done
  Stored in directory: /root/.cache/pip/wheels/c1/b0/c1/00756c24fd3ad4bba815bacbbbaa819718ecb63039e379ea6b
  Running setup.py bdist_wheel for MarkupSafe ... done
  Stored in directory: /root/.cache/pip/wheels/a3/fa/dc/0198eed9ad95489b8a4f45d14dd5d2aee3f8984e46862c5748
  Running setup.py bdist_wheel for pycparser ... done
  Stored in directory: /root/.cache/pip/wheels/a8/0b/41/dc95621f9d3a0da7bc191b8a71f0e8182ffd3cc5f33ac55005
Successfully built uwsgi itsdangerous cryptography MarkupSafe pycparser
Installing collected packages: uwsgi, click, MarkupSafe, Jinja2, Werkzeug, itsdangerous, flask, six, idna, pyasn1, pycparser, cffi, cryptography, pyOpenSSL
Successfully installed Jinja2-2.8 MarkupSafe-0.23 Werkzeug-0.11.11 cffi-1.9.1 click-6.6 cryptography-1.6 flask-0.11.1 idna-2.1 itsdangerous-0.24 pyOpenSSL-16.2.0 pyasn1-0.1.9 pycparser-2.17 six-1.10.0 uwsgi-2.0.14

Create a wsgi wrapper to run the application, say, wsgi.py, bearing in mind that
uwsgi expects the imported application to be called application,

wsgi.py should contain

from PackageInventoryServer import app as application

if __name__ == "__main__":
    application.run()

It can be launched using,

$ uwsgi --socket 0.0.0.0:5000 --protocol=http -w wsgi

Provide a wrapper for uwsgi to launch the Flask application, create a file
describing how to run the application, called, say, application.ini, with

[uwsgi]
module = wsgi

master = true
processes = 5

socket = application.sock
chmod-socket = 666
vacuum = true

die-on-term = true


The chmod-socket setting needs to be sufficient for the user running the
virtualenv; nginx runs as http on Arch Linux.

The wsgi application can be started in the virtual environment using,

# uwsgi --ini application.ini

Use the following Nginx configuration,
server {
    listen        443;
    ssl on;
    server_name inventory-master.localdomain;

    ssl_certificate      /etc/nginx/ssl/inventory-master.crt;
    ssl_certificate_key  /etc/nginx/ssl/inventory-master.key;
    ssl_client_certificate /path/to/intermediate/certs/ca-chain.crt.pem;
    ssl_verify_client on;

    location / {
        root           /var/www/example.com/html;
        root   html;
        index  index.html index.htm;
        include uwsgi_params;
        uwsgi_pass unix:/var/www/application/application.sock;
    }
}

Keep ssl_verify_client as optional while developing the solution.

The nginx environment can be tested with 'nginx -t' and started normally with

# systemctl start nginx

Although a browser won't be the interface that the application is using, we can
still view the site by pointing https://inventory-master.localdomin/
The ssl_verify_client option set to 'on' should mean that a plain request for a
resource is returnned with a '400' bad request: No required SSL certificate was sent.


Testing with cURL:

curl -v https://inventory-master.localdomain/package-inventory/packages/new -cacert file:///home/julian/Projects/python/client-cert-auth/intermediate-ca/certs/ca-chain.cert.pem -cert file:////home/julian/Projects/ruby/package-inventory-server/python/ssl/fnunbob.localdomain.cert.pem -k
curl -v https://inventory-master.localdomain/package-inventory/packages/new -cacert file:///home/julian/Projects/python/client-cert-auth/intermediate-ca/certs/ca-chain.cert.pem -cert file:///home/julian/Projects/ruby/package-inventory-server/python/ssl/fnunbob.localdomain.cert.pem -key file:///home/julian/Projects/ruby/package-inventory-server/python/ssl/fnunbob.localdomain.key.pem -k -d '{"hostname": "fnunbob.localdomain", "Packages": [{"Version": "1:1.2.8-7", "Architecture": "x86_64", "Name": "zlib", "Description": "Compression library implementing the deflate compression method found in gzip and PKZIP", "URL": "http://www.zlib.net/"}]}'

curl -k -v https://inventory-master.localdomain/package-inventory/packages/new -d '{"hostname": "fnunbob.localdomain", "Packages": [{"Version": "1:1.2.8-7", "Architecture": "x86_64", "Name": "zlib", "Description": "Compression library implementing the deflate compression method found in gzip and PKZIP", "URL": "http://www.zlib.net/"}]}'

When testing in Python using Requests, we will need to trust the self-signed
cert as described at http://stackoverflow.com/questions/30405867/how-to-get-python-requests-to-trust-a-self-signed-ssl-certificate
using 'verify=False'; specifying the path to the public key doesn't work.

It might be possible to start flask with SSL options as described at
http://kracekumar.com/post/54437887454/ssl-for-flask-local-development


Troubleshooting
===============

If the following error is received:

/usr/lib/python3.5/site-packages/urllib3/connection.py:337: SubjectAltNameWarning: Certificate for inventory-master.localdomain has no `subjectAltName`, falling back to check for a `commonName` for now. This feature is being removed by major browsers and deprecated by RFC 2818. (See https://github.com/shazow/urllib3/issues/497 for details.)
  SubjectAltNameWarning
send_package_list: <html>
<head><title>400 The SSL certificate error</title></head>

See [7]

Edit the config being used to sign the CSRs and add a new section,

[ alternate_names ]
DNS.1 = inventory-master.localdomain
DNS.2 = www.inventory-master.localdomain

And then add,

subjectAltName      = @alternate_names

to the section pointed to by x509_extensions (usually [v3_ca] although perhaps
[v3_intermediate_ca] would be more accurate in this case).

Make sure that the certificate request is created using an SSL config that
includes the SAN (SubjectAltName) configuration and that an openssl configuration
that contains req extensions that feature SubjectAlternateNames is used:

openssl x509 ... -extensions v3_req -extfile intermediate-openssl.conf

The openssl conf in this example would include:

[ v3_req ]

# Extensions to add to a certificate request

basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alternate_names

And then including this in

[req]
...
req_extensions     = v3_req

See [5] and [6]

References
==========
Python local CA
[1] https://pypi.python.org/pypi/blitz-ca/0.1.1
[2] http://stackoverflow.com/questions/33504746/doing-ssl-client-authentication-is-python

[3] http://stackoverflow.com/questions/9093289/how-to-create-a-dual-authentication-https-client-in-python-without-lgpl-libs
[4] http://twistedmatrix.com/documents/current/core/howto/ssl.html#client-authentication
[5] http://wiki.cacert.org/FAQ/subjectAltName - Adding SubjectAltName to a cert
Might be possible to use https://github.com/httplib2/httplib2 but it doesn't
look like it supports SSL client auth.
[6] http://apetec.com/support/generatesan-csr.htm - for creating SAN server
certificates (even though the cert creation command is missing a space in the
argument list).
[7] http://stackoverflow.com/questions/21488845/how-can-i-generate-a-self-signed-certificate-with-subjectaltname-using-openssl
gives a good description; ignore the off-topic moan; it is directly related
to programming as I can testify in this example.
[8] http://blog.nategood.com/client-side-certificate-authentication-in-ngi
[9] https://jamielinux.com/docs/openssl-certificate-authority/ - an ecxellent
guide except that it is missing the need to use SubjectAlternateNames.
